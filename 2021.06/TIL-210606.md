**[210606]**



# [JWT] 토큰 기반 인증과 JWT

> 출처🙇‍♀️
>
> https://velopert.com/2350, https://velopert.com/2389

## 토큰 기반 인증

### 토큰 기반 인증을 쓰는 이유 (장점)

- Stateless(무상태) 서버

  > Stateful 서버의 경우 세션 등을 저장해야 함
  >
  > 유저가 로그인 시, 로그인되었다는 상태를 세션에 저장해 사용한다.
  >
  > 세션이 '저장'되어야하므로 서버 메모리/DB 등을 사용하게 됨

  - Stateless 서버는 상태를 유지하지 않고, 클라이언트의 request만으로 작업을 처리.
  - 클라이언트-서버 연결고리가 없기 때문에, 서버의 확장성(Scalability)이 높아짐

- 모바일 어플리케이션에 적합

  - 모바일 앱 API를 만들기 위해서는 쿠키 컨테이너를 사용해야 함
  - 토큰기반인증을 도입하면 간단하게 문제를 해결

- 인증정보를 다른 어플리케이션으로 전달

  - 대표 예시 : OAuth
  - 소셜 계정들을 이용해 다른 웹서비스에서 로그인 가능

### 왜 토큰을 쓰게 되었을까?

토큰기반인증이 나타나게 된 역사.

#### 서버 기반 인증 (Stateful 서버)의 문제점

- 세션
  - : 유저가 인증을 할 때, 서버가 그 기록을 서버에 저장하는 것
  - 세션은 메모리/디스크/DB에 저장할 수 있음. 대부분 메모리에 저장
  - 메모리에 저장 시) 로그인 유저가 많아지면 램이 과부하됨.
  - DB에 저장 시) 역시 유저가 많아지면 DB성능에 영향을 줌
- 확장성
  - 세션을 쓰면 서버 확장이 어려움.
  - 서버 확장 = 서버 사양 업그레이드 가 아닌, 더 많은 트래픽을 감당하기 위해 여러 프로세스를 돌리거나 여러 대의  서버컴퓨터 추가를 의미함
  - 세션을 사용하는 분산 시스템을 설계하려면 매우 복잡하고 어려워짐
    - 유저가 처음 로그인했던 그 서버 컴퓨터로만 요청을 보내도록 설계해야하기 때문
- CORS(Cross-Origin Resource Sharing)
  - 세션 관리 시 자주 사용되는 '쿠키'는 단일 도메인 및 서브 도메인에서만 작동하도록 설계됨.
  - 쿠키를 여러 도메인에서 관리하기는 번거로워짐

### 토큰 기반 인증의 작동원리

토큰 기반 시스템은 stateless함. 즉 세션을 사용하지 않음

토큰 기반 시스템 구현 방식

1. 유저가 로그인함
2. 서버 : 해당 계정정보를 검증
3. 계정정보가 정확하면 서버가 유저에게 signed토큰을 발급 (signed = 서버로부터 정상적으로 발급된 토큰임을 의미)
4. 클라이언트 : 받은 토큰을 저장해 두고, 이후 서버에 요청을 할 때마다 토큰을 함께 전달함 (웹서버의 경우 HTTP 헤더에 토큰을 넣어 전달)
5. 서버 : 토큰을 검증한 뒤 요청에 응답함

### 토큰의 장점

- 무상태 stateless
  - 서버의 확장성 scalability을 높임
- 보안성
  - 쿠키 사용에 따른 취약점이 사라짐
  - but 토큰 사용에서도 취약점이 존재할 수 있긴 함 - 대비해야.
- 확장성 Extensibility
  - 서버의 확장성 (scalability)과는 다른 개념
  - 로그인 정보가 사용되는 분야를 확장하는 것을 의미함 
  - 토큰을 사용해 다른 서비스에서도 그 권한을 공유할 수 있다. OAuth
  - 토큰에 선택적 권한만 부여해 발급할 수 있다
- 여러 플랫폼, 도메인 
  - 토큰을 사용하면 CORS에 자유로워짐
  - 어떤 디바이스, 어떤 도메인에서도 토큰만 유효하다면 요청을 처리할 수 있음
  - 여러 디바이스 호환 및 다양한 서비스 제공 가능
  - 서버측이 보내는 Response Header에 다음 헤더만 포함하면 됨
    - `Access-Control-Allow-Origin: *`
- 웹 표준 기반
  - JWT(토큰기반인증시스템 구현체)는 웹 표준에 등록되어 있음
  - 여러 환경에서 지원되며 사용 가능

## JWT

### JWT란?

JWT = JSON Web Token.

- 웹 표준으로서 두 개체에서 JSON객체를 사용해
- 가볍고, 자가수용적인 방식으로
- 정보를 안전하게 전달
- 수많은 프로그래밍언어에서 지원
- 자가수용적(self-contained)
  - JWT는 필요한 모든 정보를 토큰 내에 자체적으로 가지고 있음
- 쉽게 전달될 수 있음
  - HTTP헤더, URL 파라미터 .. 등으로 전달 가능

### JWT가 사용되는 상황

- 회원 인증
  - 서버 : 로그인 시, 해당 유저정보에 기반한 토큰 발급
  - 클라이언트 : 매 요청에 JWT를 포함해 전달
  - 서버 : 매 요청을 받을 때 마다 해당 토큰이 유효하고&인증되었는지 검증 후, 요청 작업에 대해 권한이 있는지 확인한 뒤 요청 처리
- 정보 교류
  - 정보가 sign이 되어있기 때문에, 수신자가 바뀌거나 내용이 조작되었는지 검증 가능

### JWT의 생김새

JWT는 `.`을 구분자로 한 3개의 부분으로 되어 있음.

- 헤더 header
  - 헤더는 두 가지 정보를 지님
  - `typ` : 토큰의 타입을 지정. = `"JWT"`
  - `alg` : 보통 `HS256`, `RSA`가 사용됨
    - signature부분에서 토큰 검증 시 사용됨
  - 예제 Header
- 내용 payload
  - 내용에는 토큰에 담을 정보가 들어 있음
  - 클레임 claim : payload에 담는 정보의 한 조각. 
    - name, valued의 한 쌍으로 이루어짐
    - 토큰에는 여러 개의 클레임을 넣을 수 있음
  - 등록된(registered) 클레임
    - JWT에 등록되어 이름이 정해진 클레임
    - 등록된 클레임의 사용은 선택적(optional)임
    - `iss`(토큰 발급자, issuer), `sub`(토큰 제목, subject), `aud`(토큰 대상자, audience), `exp`(토큰 만료시간, expiration), `nbf`(토큰 활성날짜, not before), `iat`(토큰 발급시간, issued at), `jti`(JWT 고유 식별자. 일회용 토큰에 사용)
  - 공개(public) 클레임
    - 충돌이 방지된 이름을 가지고 있어야.
    - 클레임 이름을 URI형식으로 지정
  - 비공개(private) 클레임
    - 서버-클라이언트 간 협의하에 사용되는 클레임.
    - 이름이 중복되어 충돌이 일어날 수 있음
- 서명 signature
  - Header의 인코딩값, Payload의 인코딩값을 합친 후 주어진 secret key로 해쉬를 하여 생성



---

자바, 스프링으로 JWT 사용 예시는 [여기](https://meetup.toast.com/posts/239)를 참고해 만들어야겠다.