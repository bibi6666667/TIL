**[210630]**



(어제에 이어서 작성)



# Hello Coding 알고리즘

## 2장. 선택 정렬

배열, 연결리스트, 선택 정렬에 관해 공부한다.

### 메모리가 동작하는 방법

컴퓨터 메모리의 동작 방식. 

- 엄청나게 많은 서랍이 있고, 각 서랍에는 주소가 붙어 있다.
- 메모리에 무언가를 저장할 때는 컴퓨터에게 공간을 요청한다.
- 여러 개의 원소를 저장할 때, '배열'과 '리스트' 두 방식 중 하나를 선택한다.

### 배열 vs 연결 리스트

#### 배열 (array)

- 친구들과 영화를 보러 가서 자리를 찾을 때에 비유할 수 있다.
- 3명이서 좌석을 예약했는데 한 명이 더 왔다면, 4명이서 붙어 앉을 수 있는 좌석으로 다 같이 옮겨 앉아야 함
- 배열의 모든 원소는 같은 자료형이어야 한다.
- 장점 : READ가 빠르다.
  - **인덱스 index** : 배열에서는 모든 원소의 주소를 다 알고 있다.
    - 인덱스는 1이 아니라 0부터 시작. (0, 1, 2, 3 ...)
  - 즉 배열에서는 배열 안의 어떤 원소든 바로 찾을 수 있다. (`O(1)` , 고정 시간)
  - 임의의 원소 값을 찾는 데 최적이다.
- 단점 : INSERT, DELETE가 느리다.
  - INSERT - 공간이 모자라면, 매번  배열의 모든 원소를 메모리의 새로운 위치로 옮겨야 한다. (`O(n)` , 선형 시간)
  - 순서를 바꿀 때도 뒤에 오는 모든 원소의 위치를 바꾸어야 하기 때문에 느리다.
  - DELETE - 마찬가지로 삭제한 원소 때문에 다른 원소들을 옮겨야 하기 때문에 느리다. (`O(n`), 선형 시간)
- 보완 : 만약을 대비해 미리 n개의 자리를 예약한다
  - 한계 1 : 만약의 경우가 생기지 않는다면 메모리를 낭비하게 됨
  - 한계 2 : n개보다도 배열이 커진다면 또 다시 모든 원소를 옮겨야 함

#### 연결 리스트 (linked list)

- 보물찾기에 비유할 수 있다.
  - 1번째 장소로 가면 '다음으로 2번째 장소 ~~ 로 가시오', 2번째 장소로 가면 '다음으로 3번째 장소 ~~로 가시오' ...
- 연결 리스트 사용 시, 원소를 메모리의 어느 곳에나 둘 수 있다.
  - 영화 보러 가서 4명이 붙어 앉을 수 있는 자리가 없다면 각자 흩어져서 영화를 보는 것과 비슷.
- 각 원소마다 리스트의 다음 원소에 대한 주소가 저장되어 있다.
- 장점 : INSERT, DELETE가 빠르다.
  - INSERT - 메모리의 아무 곳에나 데이터를 넣고, 그 주소를 바로 앞 원소에 저장하면 됨 (`O(1)`, 고정 시간)
  - 순서를 바꿀 때도 주솟값만 수정하면 되므로 매우 쉽다.
  - DELETE - 마찬가지로 데이터 삭제 후 앞 원소에서 주솟값을 삭제하면 되므로 빠름 (`O(1)`, 고정 시간)
- 단점 : READ가 느리다.
  - 원하는 데이터의 주소를 바로 알 수 없기 때문에, 그 데이터의 주솟값을 가진 이전 데이터들을 전부 찾아야 함 (`O(n)`, 선형 시간)
  - 모든 원소의 값을 한 번에 읽는 데에는 좋지만, 특정 원소를 조회할 때는 연결 리스트는 최악임.

### 인덱스 index

원소의 위치 번호. 0부터 시작한다.

`[10, 20, 30, 40]` 이라는 배열에서, 원소 `20`은 인덱스 1에 있다.

### 임의 접근 vs 순차 접근

#### 임의 접근 random access

- 조회를 위해 해당 원소로 바로 접근하는 방식 (ex. 배열)

#### 순차 접근 sequential access

- 조회를 위해 원소를 첫 번째부터 하나씩 읽는 방식 (ex. 연결 리스트)

### 선택 정렬 selection sort

어떤 목록을 정렬하기 위해 원소마다 전체 리스트를 조회하고, 새 목록에 이를 기록함.

#### 동작원리

예를 들어 플레이리스트를 많이 들은 곡 - 적게 들은 곡 순서로 정렬하고 싶을 때,

1. 전체 목록을 돌며 가장 많이 들은 곡을 찾는다 (`O(n)`)
2. 새 목록에 그 곡을 기록한다
3. 전체 목록을 돌며 두 번째로 많이 들은 곡을 찾는다 (`O(n)`)
4. 새 목록에 그 곡을 기록한다
5. 목록 전체를 정렬할 때까지 반복한다.

시간 계산 : 목록의 모든 원소를 조회하는 작업을 원소의 갯수만큼 반복함. 따라서 `O(n x n) = O(n제곱)` 만큼 걸림.

※ 매 반복마다 조회할 목록은 줄어들지만, 빅오표기법에서는 상수항을 무시하기 때문에 `O(n제곱)` 으로 표기한다.

#### 특징

깔끔한 알고리즘이지만 빠르지 않다.

#### 선택정렬 코드

배열을 작은 정수에서 큰 정수 순으로 정렬하는 코드.

배열에서 가장 작은 원소를 찾는 함수를 작성하고, 그 함수를 이용해 정렬한 결과를 새 배열에 담는다.

```python
def findSmallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1, len(arr)):
        if arr[i] < smallest: ## 설정한 최솟값보다 배열의 i번째 값이 작다면
            smallest = arr[i] ## 그 값이 최솟값이 된다
            smallest_index = i
    return smallest_index

def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr

print selectionSort([5, 3, 6, 2, 10])
```





## 3장. 재귀

### 시작하기에 앞서

- 예제 코드 직접 실행해 보기
- 적어도 한 번은 연필과 종이를 가지고 재귀함수의 실행 과정을 따라가 보기.
- 의사코드(pseudocode, 슈도코드) : 문제와 풀이 방법을 간단한 코드로 설명한 것. 실제로 동작하진 않음

### 재귀 recursion

- 재귀 
  - 함수가 자기 자신을 호출하는 것.

문제 : 여러 겹으로 포장된 상자들이 있고, 그 상자가 또 다른 상자들 속에 들어 있다. 몇 개일지 모르는 상자들 중 열쇠가 들어있는 상자를 찾아야 한다.

#### 방법 1 : 반복문 사용하기

1. 내부를 확인할 상자를 쌓아놓는다(=상자 더미).
2. 상자 하나를 집어서 내부를 확인한다.
   1. 만약 안에 상자가 있다면, 확인할 상자 더미에 놓은 뒤 2로 돌아간다.
   2. 만약 안에 열쇠가 있다면 작업을 종료한다.

아래는 위 과정에 대한 슈도코드.

```python
def look_for_key(main_box):
    pile = main_box.make_a_pile_to_look_through()
    while pile is not empty:
        box = pile.grab_a_box()
        for item in box:
            if item.is_a_box():
                pile.append(item)
            elif item.is_a_key():
                print "열쇠를 찾았어요!"
```

#### 방법 2 : 재귀 사용하기

1. 상자 안을 확인한다.
   1. 만약 상자를 발견하면 1.로 간다.
   2. 만약 열쇠를 발견하면 작업을 종료한다.

아래는 위 과정에 대한 슈도코드.

```python
def look_for_key(box):
    for item in box:
        if item.is_a_box():
            look_for_key(item)
        elif item.is_a_key():
            print "열쇠를 찾았어요!"
```

### 재귀의 특징

- 알고리즘 풀이를 명확하게 해 준다.
  - 성능이 더 나아지는 것은 아님. 성능은 반복문이 더 좋다.
- "프로그램에 반복문을 사용하면 프로그램의 성능을 향상시킬 수 있지만, 재귀를 사용하면 프로그래머의 능력을 향상시킬 수 있습니다. 상황에 따라 적절한 방법을 골라 사용하세요."
- 대부분의 중요한 알고리즘들이 재귀를 사용한다.

### 기본 단계와 재귀 단계

재귀함수는 자기 자신을 호출하기 때문에 무한루프에 빠지기 쉽다.

재귀함수를 만들 때에는 언제 재귀를 멈출지 반드시 알려 주어야 한다.

그래서 모든 재귀함수는 기본 단계와 재귀 단계로 나누어져 있다.

- 기본 단계 base case : 재귀를 빠져나가는 단계. 무한반복에 빠지는 것을 막는 부분이다.
- 재귀 단계 recursive case : 함수가 자기 자신을 호출하는 단계.

아래는 카운트다운을 하는 코드. (무한루프)

```python
def countdown(i):
    print i
    countdown(i-1)
```

무한루프 코드에 기본 단계를 추가하면 정상 동작하는 재귀함수를 만들 수 있다.

```python
def countdown(i):
    print i
    if i <= 1: ## 기본 단계
        return
    else: ## 재귀 단계
        countdown(i-1)
```

### 스택 (콜 스택)

호출 스택은 프로그램의 중요 개념이다. 재귀를 사용할 때는 더 중요하다.

**스택 stack** : 푸시(push, 삽입)와 팝(pop, 빼내서 읽기) 두 동작만 가능한 자료구조.

- 푸시 : 가장 위에 새 항목을 추가
- 팝 : 가장 위의 항목을 빼내어 읽기

#### 콜 스택 (call stack, 호출 스택)

컴퓨터가 함수에 사용되는 변수를 저장하는 스택을 콜 스택이라고 한다.

함수가 한 번 호출될 때 마다, 컴퓨터는 그 함수 호출에 필요한 메모리를 할당해 스택으로 쌓는다(push).

- 함수에 사용된 변수도 해당 함수의 스택 내에 저장된다.
- 해당 함수가 종료(리턴)되기 전까지 그 스택은 유지된다.
  - 해당 함수가 종료(리턴)되면 그 스택은 사라진다(pop).
- 함수(A) 내에서 다른 함수(B)를 호출하면, A 스택 위에 B 스택이 쌓인다.
  - 함수 호출 후 종료되기 전이라도 다른 함수를 호출할 수 있으며, 이 때 중지된 함수의 변수 값들은 해당 스택으로 메모리에 저장된다.
  - 맨 위에 쌓여 있는 스택이 현재 실행되고 있는 함수에 대한 스택이다.

#### 재귀 함수에서 콜 스택 사용

재귀 함수도 콜 스택을 사용한다.

아래는 팩토리얼 함수에 대한 재귀함수. 

- 콜스택 모양은 꼭 교재를 확인하자 : 59~61페이지.

```python
def fact(x):
    if x == 1:
        return 1
    else:
        return x * fact(x-1)
```

#### 재귀 함수에서 콜 스택의 역할은?

= 반복문에서 필요했던 상자 더미(`pile`)의 역할.

재귀를 사용해 구현하면, 확인해야 할 상자 더미를 스택에 저장하는 것과 같다.

- 우리가 직접 상자 더미를 만들고 추적하지 않아도 되기 때문에 편리한 것!

#### 콜 스택의 단점 

: 모든 정보를 컴퓨터 메모리에 저장해야 하므로 메모리를 많이 소비한다.

- 함수 호출을 한 번 할 때마다 메모리를 사용하게 됨.
- 재귀가 깊어져 스택이 커지면, 컴퓨터가 과다한 함수 호출정보를 저장하게 됨
- 재귀가 깊어지면(특히 무한루프에 빠지면) 스택이 계속 커지는데, 모든 프로그램은 콜스택에 할당할 수 있는 메모리 공간이 정해져 있으므로 그 공간을 다 사용하면 스택 오버플로우 오류가 발생하며 프로그램이 종료된다.

해결 1 : 재귀 대신 반복문으로 전환

해결 2 : 꼬리재귀 tail recursion 방법을 사용 - 고급 재귀 방법.