**[210208]**



자바코스 첫 수업



---



# TIL



## 1. 깃 시작하기

#### Git이란?

(소스코드를 관리하는) 분산형 버전 관리 시스템.

소스 코드 관리를 쉽게 해 준다.



#### Git에서 가장 중요한 것은?

**커밋**이다.

커밋 : 나 또는 팀원 누군가의 작업 **디렉토리**의 **스냅샷**이다.

게임으로 치면 **세이브포인트**.

커밋을 하고 나면 언제든지 그 시점으로 돌아갈 수 있다.

* Git은 파일의 변경사항만이 아니라, 전체 내용을 저장한다.

#### Git 개념

- 워킹트리 : 작업 디렉토리. 우리가 작업하는 공간(폴더). Git의 입장에서는 샌드박스

- 스테이지(인덱스) : 커밋을 준비하는 공간. 
- 커밋 : 스테이지에 있는 내용을 가지고 커밋을 만들 수 있다.
  - 커밋할 대상은 선택할 수 없다. (스테이지에 올라간 모든 파일은 커밋된다)
  - 스테이지에 올라갈 대상을 선택할 수 있을 뿐이다.
- 로컬저장소 : `.git`디렉토리. 커밋의 집합이다.
  - `.git`폴더에는 스냅샷들이 저장되기 때문에 로컬저장소이다.

- 원격저장소 : 로컬 저장소를 서버에 복사한 것 (로컬 저장소 == 원격 저장소)
- 브랜치 : 작업의 흐름을 제어하기 위해 사용.
  - 브랜치는 사실 커밋의 참조일 뿐이다. (커밋에 이름 붙인 것일 뿐)
  - `HEAD` : 현재 작업 중인 브랜치. `HEAD`는 브랜치의 참조이다.
- 태그 : 



#### 왜 Git을 사용하는가?

버전 관리, 백업, 협업을 위해 사용한다.

- 버전 관리 Version control 
  - 문서를 언제 수정했고 어떤 부분을 변경했는지 기록함.
- 백업 Backup
  - 필요성
    자료를 컴퓨터에만 저장한다면 언젠가는 그 자료가 유실된다.
    내 컴퓨터는 언젠가는 고장나고, 그게 언제가 될 지는 모른다.
    따라서 반드시 백업을 해야 함.
  - 백업이란? 컴퓨터의 자료를 다른 컴퓨터에 복제하는 것
    - 원격 저장소(온라인 저장소)
      : (깃허브`Github`처럼) 깃 파일을 위한 백업 공간을 제공하는 인터넷 서비스.
- 협업 Collaboration
  - 깃허브를 통해 협업이 쉬워진다.

#### 깃 프로그램의 종류

다양한 깃 프로그램들이 존재한다 - 깃을 좀 더 편리하게 사용할 수 있게 해 줌.

- 깃허브 데스크톱 Github Desktop (GUI - 초급)
- 소스트리 SourceTree (GUI - 고급)
- CLI로 터미널 창에 직접 명령을 입력해 사용할 수도 있다.
  - 기본 리눅스 명령과 깃 명령어를 외워야 한다.
  - 익숙해지면 훨씬 빠르다, 자동화가 가능하다, 서버환경에서 깃 사용이 가능하다.
  - 깃 배시 Git bash
    : 윈도우에 깃을 설치하면 함께 설치됨. 
    깃이 리눅스 명령어를 사용하기 때문에 깃배시로 리눅스 명령을 사용할 수 있게 된다.



> 커맨드 라인 vs 터미널
>
> : 리눅스 명령을 입력할 수 있는 창을 뜻한다.
> 윈도우에서는 커맨드라인(명령 프롬프트), 맥에서는 터미널이라고 부른다.



### 깃 명령어 (기초)

- `$ git config` : 깃 사용자 정보 설정

  - `--global` 옵션 : 현재 컴퓨터의 모든 저장소에서 같은 사용자 정보를 사용하도록 설정
  - `$ git config --global user.name "이름"`
  - `$ git config --global user.email "이메일주소"`

  

### 깃 명령어 (리눅스 공통)

- `~` : 현재 홈 디렉토리에 있다는 표시.
  (디렉토리 = 폴더)

> **홈 디렉토리** : `/c/Users/사용자아이디` 를 나타냄.

- `pwd` : print working directory. 현재 위치 경로를 나타냄.
- `ls` : list. 현재 디렉토리에 어떤 파일 및 디렉토리가 있는지 확인함.
  - 이름 뒤에 `/`가 붙은 것이 디렉토리이다.
- `clear` : 화면을 깨끗이 정리함.
- `-` : 명령에 옵션을 추가하는 붙임표.
  - `ls -a` : all? 숨긴 파일 및 디렉토리 표시
  - `ls -l` : 파일 및 디렉토리의 상세 정보 표시
  - `ls -r` : 파일 정렬순서를 거꾸로 표시
  - `ls -t` : 파일의 작성시간 순으로 표시(내림차순)
  - `ls -la` 또는 `ls -al`처럼 두 옵션 함께 사용도 가능. (순서는 상관없음)
- `cd` : change directory. 터미널 창에서 디렉토리 사이를 이동함.
  - `cd ..` : 현재 위치에서 상위 디렉토리로 이동
  - `cd 하위디렉토리명` : 하위 디렉토리로 이동
  - `cd ~` : 홈 디렉토리로 이동

> 리눅스의 디렉토리 기호
>
> `~` : 홈 디렉토리
> `./` : 현재 작업중인 디렉토리
> `../` : 현재 디렉토리의 상위 디렉토리

- `mkdir 폴더명` : 현재 디렉토리에서 하위 디렉토리 생성

- `rm 폴더명` : remove. 디렉토리 삭제
  - 삭제할 디렉토리의 상위 디렉토리로 이동한 후 사용해야 함.
  - `rm -r 폴더명` : 하위 디렉토리 및 파일까지 모두 삭제 (디렉토리일 경우 반드시 붙이는 옵션)

- `cat 파일명` : concatenate(연쇄하다) 파일의 내용을 화면에 표시함
- `cat 파일1, 파일2 .. 파일n > 새파일` : 파일1, 2 .. n들을 차례로 연결해 새파일로 만듦
- `cat 파일1 >> 파일2`  : 파일1 내용을 파일2끝에 연결함





### 빔 vim

vim : 리눅스의 기본 편집기. (윈도우의 메모장처럼)

- 터미널에서 사용할 수 있는 대표적인 편집기.

- 터미널창에서 키보드 입력만으로 사용함.

### 모드

빔은 처음에 ex모드로 실행된다.

- ex모드 : `Esc`를 눌러서 전환. 파일저장, 종료가 가능한 상태.
- 입력 모드 : `i`를 눌러서 전환. 텍스트 입력 및 수정이 가능한 상태.

#### 빔 명령어

- `vim 파일명` 
  : 해당 파일이 있다면 그 파일을 vim으로 연다.
  : 해당 파일이 없다면 그 이름으로 새로운 문서를 만들고 vim으로 연다.
- `i` : 입력 모드로 전환
- `Esc` : ex모드로 전환
  - `:` : ex모드에서 명령어 입력
    ex모드에서 사용하는 명령은 모두 `:`로 시작함.
- `:wq` : 저장 및 종료
- `:wq 파일명` : 파일명 으로 저장 및 종료
  - `:w` : write. 문서를 저장함
  - `:q` : quite. 편집기를 종료함





---



## 2. 깃으로 버전 관리

깃 버전 관리를 위해서는, 먼저 특정 디렉토리에서 깃을 초기화해야 한다.

- `git init` : initialize(초기화하다) 현재 디렉토리에 저장소(`.git`)를 만듦.
  (깃을 사용할 수 있도록 디렉토리를 초기화함)
  - `.git` : 깃을 사용하면서 버전이 저장될 저장소(repository).
    숨김 파일이다 (사용자가 실수로 .git을 지우지 않도록 하기 위해)

#### **버전**이란?

: (프로그램 개발에서) 수정 내용이 쌓여 이전 상태와 구별된 것. 새로 번호를 붙여서 관리함.
0.0.1 - 0.0.2 - ... - 2.23.0 과 같이 구분

: (깃에서) 문서를 수정 및 저장할 떄마다 생기는 것.

#### 작업 트리, 스테이지, 저장소 및 커밋

- **작업 트리 working tree (또는 작업 디렉토리)**
  : 파일 수정, 저장 등 작업을 하는 디렉토리. 우리 눈에 보이는 디렉토리에 해당함.
- **스테이지 stage (또는 스테이징 영역)**
  : (`.git`에 숨겨져 있다)
  버전으로 만들 파일이 대기하는 곳. 
  수정한 파일 중 버전으로 만들 파일을 스테이지로 보내면 된다.
  - `.git/index` : 스테이지의 내용은 `.git` 디렉토리의 인덱스 파일에 저장됨
- **저장소 repository (리포지토리)**
  : (`.git`에 숨겨져 있다)
  스테이지의 대기 파일들을 버전으로 만들어 저장하는 곳.
  - `.git/HEAD` : 저장소의 내용은 `.git`디렉토리의 HEAD파일에 저장됨
- **커밋 commit**
  : 스테이지의 대기 파일들을 버전으로 만들어 저장소에 저장하는 명령.

#### 깃 상태 확인

- `git status` 
  : 깃 상태를 확인하는 명령어.
  - `On branch master` : 현재 마스터 브랜치에 있다.
  - `No commits yet` : 아직 커밋한 파일이 없다.
  - `nothing to commit` : 현재 커밋할 파일이 없다. =버전으로 만들 파일이 없다.
  - `Untracked files : 파일명` : 한 번도 버전관리를 하지 않은 파일이 있다.
  - `Changes to be committed : 파일명` : 새 파일을 앞으로 커밋할 것이다.
  - `working tree clean` : 작업 트리가 수정사항 없이 깨끗하다.
  - `Changes not staged for commit : 파일명` : 파일이 수정되었고 아직 스테이징되지 않았다.

#### 스테이징 - `add`

- `git add 파일명` 
  : 작업 트리에서 생성 또는 수정한 파일을 스테이지에 추가하는 명령어.
  '스테이징 staging' 또는 '인덱스에 등록한다' 라고 함.

- `git add .`
  : 작업 트리에서 수정한 파일들을 한꺼번에 스테이지에 추가함.

  - `add`로 추가하면 스테이징이 끝난 것 = 버전을 만들 준비가 되었다.

  - `warning: LF will be replaced by CRLF in 파일명.`
    `The fill will have its original line endings in your working directory`
    : (의미)깃에서 자동으로 텍스트문서의 CRLF문자를 LF문자로 변환해 커밋하겠다.
    윈도우와 리눅스의 줄바꿈문자( = 개행문자, end of line, eol, line endings)가 달라서 나타나는 경고.

    > 윈도우는 파일 저장시, 줄바꿈 자리에 CR문자와 LF문자가 삽입됨 (=CRLF)
    > 반면 리눅스 & 맥은 파일 저장시, 줄바꿈 자리에 LF문자가 삽입됨
    > 깃은 리눅스 환경이므로 윈도우 텍스트문서를 스테이징할 때 위와 같은 경고 메시지가 나오는 것.
    > (메시지 뜻만 이해하고 넘어가면 된다)

#### 커밋 -  `commit`

- `git commit -m "커밋메시지"`
  : 깃에서 파일을 커밋하는 명령어. 
  스테이지에 있는 파일의 버전을 저장소에 저장함.
  - `-m` : 커밋메시지를 추가하는 옵션. 커밋메시지는 주로 영어로 작성
  - `1 file changed, 1 insertion(+)`
    : 파일 1개가 변경되었고, 파일에 1개의 내용이 추가되었다.
    (커밋한 파일이 저장소에 추가됨)
- `git commit -am "커밋메시지"` (또는 `git commit -a -m "커밋메시지"`)
  : `add` + `commit`. 
  깃에서 스테이징과 커밋을 한꺼번에 처리하는 명령어.
  - 한 번이라도 커밋한 적이 있는 파일 대상으로 사용 가능.

- `git commit --amend`
  : 가장 최근의 커밋 메시지를 수정

#### 커밋 로그 : 커밋 내용 확인하기

- `git log` : 커밋 기록을 살펴보는 명령어.
  지금까지 만든 버전 및 커밋 작성자, 작성시간, 커밋메시지 조회 가능.
- `git log --stat` : 각 커밋로그에 관련된 파일까지 자세히 나타낸다.
- **커밋 로그 commit log** : `git log`로 나오는 커밋 내역들을 말함.
- 로그가 너무 많은 경우 한 화면씩 나누어 보여준다.
  - `Enter`로 다음 로그화면으로 이동할 수 있음.
  - `q`로 로그 화면을 빠져나와 깃 명령을 입력할 수 있음.

![커밋로그](https://user-images.githubusercontent.com/67407678/107194087-f5d1ab80-6a32-11eb-943a-744f78cffa1e.PNG)

  -  `commit 70b22aae93090437b55f79890bd54a39c2ebb2f8`  
     : **커밋 해시 commit hash (또는 깃 해시)**.
     커밋을 구별하는 아이디에 해당함
  -  `(HEAD -> master)`
     : 해당 버전/커밋이 가장 최신 버전임을 나타내는 표시.
  -  `Author : `
     : 버전을 만든 사람
  -  `Date : `
     : 버전이 만들어진 날짜
  -  `commit message 1` 등 Date 아래의 내용
     : 작성자가 기록한 커밋 메시지



#### 변경 사항 확인하기 - `git diff`

작업트리의 파일 vs 스테이지의 파일 비교
또는 스테이지의 파일 vs 저장소의 커밋 비교할 수 있다.

- `git diff`
  : 수정한 파일 과 최신 버전을 비교하는 명령어.
  - `- 이하 빨간색 내용` : 삭제된 내용
  - `+ 이하 초록색 내용` : 추가된 내용



### 버전 만드는 단계마다 파일 상태 알아보기

깃에서는 버전을 만드는 각 단계마다 파일 상태를 다르게 표시한다.

- `git log --stat` : 각 커밋로그에 관련된 파일까지 자세히 나타낸다.

#### tracked파일과 untracked파일

작업 트리에 있는 파일은 크게 tracked파일과 untracked파일로 나뉜다.

![트랙언트랙](https://user-images.githubusercontent.com/67407678/107209777-9d0c0e00-6a46-11eb-8971-f9e79e944850.PNG)

- tracked 파일
  : 한 번이라도 커밋한 적이 있어, 깃이 수정내역을 추적하는 파일.
  - `Changes not staged for commit: ` : 변경된 파일이 스테이징되지 않음.
  - `modified: 수정된파일명` : 수정된 파일을 알려줌.
- untracked 파일
  : 한 번도 버전관리를 한 적이 없어, 깃이 수정내역을 추적하지 않는 파일.
  - `Untracked files:` ..

![트랙언트랙add](https://user-images.githubusercontent.com/67407678/107210718-e0b34780-6a47-11eb-93d2-f64c94914ab8.PNG)

- tracked파일 : `add`하면 `modified`로 표시됨
- untracked파일 : `add`하면 `new file`로 표시됨



### .gitignore

: 버전 관리 중인 디렉토리 내에, 버전관리를 하지 않을 특정 파일 또는 디렉토리가 있을 떄 사용하는 숨김 파일.

- `.gitignore`라는 이름의 파일 내에 
  버전관리를 하지 않을 파일/디렉토리 이름이나 파일 확장자를 입력한다.
- 주로 자동 생성되는 .swp파일, 백업 파일, 메모 파일 등이 포함됨.



#### unmodified, modified, staged 상태

tracked 파일은 커밋 과정을 거치며 unmodified, modified, staged 상태로 바뀔 수 있다.

![unmodi](https://user-images.githubusercontent.com/67407678/107215838-363f2280-6a4f-11eb-864f-024c3bf4be8f.PNG)

- unmodified 상태
  : 마지막 커밋 후 수정되지 않은 상태. 작업 트리에 변경사항이 없음.

  - `git status` : `nothing to commit, working tree clean` 으로 나타남

- modified 상태
  : 마지막 커밋 후 수정되었으나, 아직 스테이지에 올라가지 않은 상태.

  - `git status` : `Changes not staged for commit` , `modified : 파일명(빨간색)` 으로 나타남

- staged 상태
  : 수정된 파일이 스테이지에 올라가 있는 상태. 

  - 커밋 직전 단계 - 커밋할 변경사항이 있는 상태임.
  - staged상태의 파일을 커밋하면, 해당 파일은 다시 unmodified상태로 돌아간다.
  - `git status` : `Changes to be committed`, `modified : 파일명(초록색)` 으로 나타남

  

### 작업 되돌리기 

작업 트리 - 스테이지 - 저장소 각 단계로 다시 돌아가는 방법에 대해 알아본다.

####  작업 트리에서 수정한 파일 되돌리기

- `git checkout` 
  : 수정한 내용을 취소하고, 가장 최신 버전으로 되돌리려 할 때 사용함.
  - `checkout`으로 되돌린 내용은 다시 복구할 수 없다.
- 조건 : 작업트리에서 수정되었지만 아직 스테이지에 올리지 않았을 때.
  - `Change not staged for commit`
    (구)`(use "git checkout <file>..." to discard changes in working directory)`
- ❌ 현재 `checkout`명령어는 사라지고`switch`와 `restore`로 분리된 상태.
  따라서 수정 파일을 되돌릴 때는 `checkout` 대신  `restore`를 사용한다.
  `(use "git restore <file>..." to discard changes in working directory)`
  - [`checkout`](https://git-scm.com/docs/git-checkout): Switch branches or restore working tree files
  - [`switch`](https://git-scm.com/docs/git-switch): Switch branches 
  - [`restore`](https://git-scm.com/docs/git-restore): Restore working tree files
- **`git restore 파일명`** : 해당 파일의 작업트리 변경사항을 취소함.
  (deprecated) `git checkout -- hello.txt` 도 같은 기능.

#### 스테이징 되돌리기 (unstage)

- `git reset HEAD 파일명`
  : 스테이징된 파일의 스테이징을 취소하는 명령어.

- 조건 : 스테이징된 파일 (아직 커밋하지 않았을 때)
  - `Changes to be committed : `
  - (구)`(use "git reset HEAD <file>..." to unstage`)
    - 사용 후 : `Unstaged changes after reset : 파일명`
  - (현재)`(use "git restore --staged <file>... " to unstage)`
    - 정상적으로 unstage된 경우 아무런 메시지 없음

#### 최신 커밋 되돌리기

- `git reset HEAD^`
  : 가장 마지막에 한 커밋(`HEAD -> master`)을 취소함.
  - `HEAD^` : 현재 HEAD가 가리키는 브랜치의 최신 커밋을 가리킴.
  - 사용 후 : `Unstaged changes after reset : 파일명` (unstage와 동일)
- `git reset HEAD~3`
  : 가장 최근의 3개의 커밋을 취소함.
- 취소한 파일이 작업 트리에만 남는다.
- 커밋도 취소되고 스테이지에서도 내려간다.
- `git reset --soft HEAD^` : 최근 커밋을 하기 전 상태로 작업트리를 되돌림.
- `git reset --mixed HEAD^`: 최근 커밋과 스테이징을 하기 전 상태로 작업트리를 되돌림.
  - (옵션 없이 `git reset`을 할 경우 이 옵션으로 작동함)
- `git reset --hard HEAD^` : 최근 커밋과 스테이징, 파일 수정 전 상태로 작업트리를 되돌림.
  - 이 옵션으로 되돌린 내용은 복구할 수 없음. 

#### 특정 커밋으로 되돌리기

- `git reset 커밋해시` : `커밋해시`의 커밋(버전)으로 되돌리고, 그 이후 버전은 삭제함.
  - 해당 커밋을 리셋하는 것이 아니라, 최신 커밋이 `커밋해시`커밋이 되도록 리셋하는 것임.
  - `커밋해시` : "되돌아갈 커밋해시"를 지정한다.

- `git reset --hard 커밋해시` : `커밋해시` 의 커밋으로 되돌리고, 그 이후의 커밋, 스테이징, 파일수정을 모두 삭제함.(복구 불가능)
  - 사용 후 : `HEAD is now at 커밋해시 커밋메시지`.

> 커밋해시를 복사할 때는 단축키가 아닌 마우스 클릭을 사용해야 한다.

#### 커밋 삭제하지 않고 되돌리기 (취소)

나중에 사용할 것을 대비해, 커밋을 되돌리더라도 취소한 커밋을 남겨두어야 할 때 사용.

- `git revert 커밋해시` : `커밋해시`의 커밋으로 되돌리되, 취소한 커밋까지 남겨 둠.
  - `커밋해시` : "취소할 커밋해시"를 지정한다.
- `revert` 사용 시 기본 편집기가 자동으로 나타나면서 커밋 메시지를 입력할 수 있다.
  - revert하면서 추가로 남겨둘 내용을 입력하고 저장한다
  - 사용 후 커밋메시지 : `Revert 커밋메시지`

- revert는 기존 커밋을 지우는 대신, 변경이력을 취소한 새 커밋을 만드는 방식이다.



---

## 3. 깃과 브랜치

**브랜치 branch**
: 버전 관리 시스템에서, 여러 갈래로 퍼지는 데이터 흐름을 가리키는 말.
(나뭇가지 - 나무가 가지에서 줄기를 뻗는 모양처럼.)

### 브랜치의 동작원리

- 깃으로 버전관리를 시작하면 기본 브랜치인 **main브랜치**가 만들어진다.
  - main브랜치 = (구) master브랜치.
- **HEAD**는 현재 작업중인 브랜치를 뜻한다.
  - `HEAD -> master` : 현재 작업중인 브랜치가 master브랜치임을 뜻함
- **브랜치는 커밋을 가리키는 포인터이다.
  사용자가 커밋할 때마다 main브랜치는 최신 커밋을 가리킨다. **

> 포인터pointer : (프로그래밍) 다른 변수(의 메모리 공간 주소)를 가리키는 변수를 뜻함.
>
> 간접 참조 - 값을 직접 쓰는 게 아닌 특정 메모리번지의 값을 읽어서 쓰도록 하는 것.
>
> 포인터는 서로 다른 함수 내의 변수를, 주소를 통해 제어할 수 있게 한다.

- **분기(branch) **
  : main브랜치에서 뻗어나오는 새 브랜치를 만드는 것.
  - 새 브랜치를 만들면, 기존 파일 내용을 main브랜치에 유지하면서
    기존 파일을 수정하거나 새로운 파일을 추가할 수 있다.
- **병합(merge, 머지) **
  : 분기했던 브랜치를 main브랜치에 합치는 것.
  - 새 브랜치에서 원하는 작업을 끝낸 후, 새 브랜치의 파일을 main브랜치에 합친다.