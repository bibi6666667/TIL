**[210121]**





#### 호눅스의 미션 설명

오늘 미션은 프로세스와 스레드가 무엇인지 이해해 보고, 사용해 보는 것이 목표이다. 
미션 수행에 너무 집착하지 말고 공부하는 것에 집중하자.



#### 학습 키워드

- 프로세스
  - 프로세스를 관리하는 자료구조
  - 프로세스 메모리 구조 (스택, 힙, 데이터, 텍스트)
  
- 프로세스와 스레드의 관계 및 차이

- 프로세스 스케줄링
  
  - 프로세스 상태
  
- 스레드(쓰레드)

- 스레드 스케줄링 / 병렬 처리
  
  - 다중 스레드
  
- 멀티 스레드 스케줄링

- 운영체제의 동작원리? (프로세스, 스레드 중심)

- 각자 운영체제 스레드 동작 방식

- 스레드를 무제한으로 만들수 없다면, 프로세스가 많아질 때 성능 향상을 할 수 있는 방법이 무엇일까? 

- setTimeout 내부 동작 방식에 대해 학습하고 정리한다.

  





# TIL



## 프로세스 Process



### [컴퓨터의 구조 및 프로세스 - 생활코딩](https://opentutorials.org/course/2598/14210)

- 컴퓨터의 구조

  - 하드웨어

    - **Storage 스토리지, 저장장치 - SSD, HDD**
    - **Memory 메모리 - RAM 램**
    - **Processor 프로세서 - CPU** 

  - Storage와 Memory는 둘 다 정보를 저장한다는 공통점이 있다.

    - 그렇다면 둘의 차이는?

    - Storage 
      : 가격이 싸다. 저장용량이 크다. 
      처리(읽기/쓰기) 속도가 느리다. 
      전원이 꺼져도 데이터가 남아있다.

    - Memory 

      : 가격이 비싸다. 저장용량이 작다. 
      처리속도가 빠르다. 
      전원이 꺼지면 데이터가 사라진다.

  - Storage만 사용하기에는, 
    Storage의 처리속도로는 CPU의 처리속도(빠름)를 따라잡을 수 없는 상황 발생.

  - 그래서.. 
    프로그램을 '저장'하는 곳은 Storage로 하고,
    프로그램을 '실행'시에는 Storage에서 프로그램을 읽어 Memory에 적재한다.
    ( = 실행되지 않는 프로그램은 메모리에 올라오지 않는다)
    CPU는 메모리에 올라와 있는 프로그램을 읽어서 코드대로 명령을 처리한다.

- 그래서 프로세스란 무엇인가?

  - **프로그램 program** 
    : 파일의 형태로 **Storage**에 저장되어 있는 명령어의 집합(코드).
    - 프로그램 자체에는 생명이 없다. 
  - **프로세스 process** 
    : **메모리**에 적재된 상태로 CPU에 의해 처리되는 **'실행 중인 프로그램 program in execution'**
  - **프로세서 processor** 
    : 프로세스를 처리하는 것, 즉 **CPU**의 다른 말.

  

### [운영체제 - 프로세스](https://bowbowbow.tistory.com/16)

..

- 어떻게 여러 개의 프로세스가 동시에 실행될 수 있는가?
  - 하나의 CPU(프로세서)는 매 순간 하나의 프로세스만 실행 가능하다. 
    그런데 어떻게 여러 프로세스가 동시에 실행되는 것인가?
    - **운영체제**가 엄청나게 빠른 속도로 CPU가 실행할 프로세스를 교체하고 있기 때문이다.
      인간이 '동시에 실행된다'고 느낄 정도로 빠르게 프로세스가 교체되기 때문에, 동시에 여러 개의 프로세스가 실행되고 있다고 ''느끼는'' 것이다.
    - 즉 프로세스를 구성하고 관리하는 것이 운영체제의 역할이다.

#### 프로세스의 구성

- **PCB** (Process Control Block, 프로세스 제어 블록)

  : 프로세스에 대한 정보가 저장되는 자료구조.
  운영체제가 시스템 내의 프로세스들을 관리하기 위해, 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조.

  크게 아래와 같은 정보를 담고 있다.

  - PID (Process IDentification)
    : 운영체제가 각 프로세스를 식별하기 위해 부여한 프로세스 식별번호.
  - 프로세스 상태
    : 실행 중 / 대기 중인 프로세스들의 각 상태를 저장함.
  - 프로그램 카운터
    : CPU가 다음으로 실행할 명령어를 가리키는 값.
    - CPU는 기계어를 한 단위씩 읽어서 처리하는데, 프로세스 실행을 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값이 '프로그램 카운터'이다.
  - 스케줄링 우선순위
    - **스케줄링** : 운영체제가 CPU에서 여러 프로세스들이 실행될 순서를 결정하는 것.
      스케줄링에서 우선순위가 높으면 먼저 실행된다.
  - 권한
    : 프로세스가 접근할 수 있는 자원을 결정하는 정보. 각 프로세스마다 어디까지 접근할 수 있는지에 대한 권한이 필요하다.
  - 부모 프로세스와 자식 프로세스
    - 최초로 생성되는 init프로세스를 제외한 모든 프로세스는 부모 프로세스를 복제해 생성되며, 트리 모양의 계층관계를 형성한다.
      각 프로세스는 자식 프로세스와 부모 프로세스에 대한 정보를 가지고 있다.
  - 포인터
    : 프로세스는..
    - 프로그램에 대한 정보가 저장된 메모리 주소를 가리키는 포인터 값을 가진다.
    - 프로세스에 할당된 자원들을 가리키는 포인터 값을 가진다.
  - 실행문맥 (아래 ''프로세스 문맥'' 참조)
    : 프로세스가 실행상태에서 마지막으로 실행한 프로세서의 레지스터 내용을 담고 있다.
    - 운영체제에 의해 계속 교체되는 CPU의 프로세스가 다시 실행될 때, 중단된 적 없이 연속적으로 실행된 것 처럼 실행되기 위해 이 레지스터 정보를 갖고 있다.

#### 프로세스 메모리 구조 (프로세스가 접근할 수 있는 메모리 공간)

- PCB의 구성요소 중 **포인터**에 대한 자세한 설명이다.

- 포인터 
  : 프로세스의 데이터와 명령어가 있는 메모리 위치를 가리킨다.
  여기서 '프로세스의 데이터와 명령어가 있는 메모리' 의 구성을 알아본다.

- **프로세스 메모리 구조 **
  : 프로세스가 메모리에 올라갈 때의 구조.

  > 낮은 메모리 주소값 <- **Text - Data - BSS - Heap - (빈 공간 unused memory) - Stack** -> 높은 메모리 주소값

  - **Text 영역**
    : 프로세서가 실행할 바이너리 코드, 함수 코드, 제어문, 상수를 저장하는 영역.
  - **Data (GVAR)  영역**
    : 초기화된 전역변수, static변수를 저장하는 영역. 읽고 쓰기가 가능함.
  - **BSS 영역**
    : 초기화되지 않은 전역변수, static변수를 저장하는 영역. 읽고 쓰기가 가능함.
  - **Heap (힙)영역**
    : 프로그램 실행 중, 동적으로 메모리를 할당할 수 있는 자유로운 영역.
  - **unused memory (빈 공간)**
    - Stack영역과 Heap영역 사이에 위치하는 빈 공간.
    - 컴파일 타임에 지역변수를 얼마나 사용할지 미리 계산할 수 없기 때문에, 
      스택영역은 런타임에 지역변수 선언 순서에 따라 위쪽으로 주소값을 매긴다.
      힙 영역은 동적 할당될 때 아래쪽으로 주소값을 매긴다.
  - **Stack (스택)영역**
    : 메소드나 프로시저를 호출하고 리턴할 때, 복귀 주소나 지역변수 같은 일시적인 데이터를 저장하는 메모리 영역.

#### 프로세스 스케줄링

- 프로세스 관리
  - 운영체제는 여러 프로세스들을 실행, 교체, 재시작 할 때 오류가 발생하지 않도록 관리한다.
  - 이를 위해 운영체제는 프로세스의 상태를 실행 / 준비 / 대기 라는 3가지 상태 
    (크게는 생성 / 준비 / 실행 / 대기 / 종료 라는 5가지 상태)로 분류하고, 
    상태전이(state transition)를 통해 체계적으로 관리한다.
- **프로세스의 상테**
  - **생성 new**
    : 프로세스가 생성 중인 일시적 상태.
    - 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조가 생성되었지만, 아직 메모리 획득을 승인받지 못한 상태.
    -  프로그램 실행 시 프로세스가 생성되고, 준비리스트에 추가됨.
  - **준비 ready**
    : 프로세스가 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태.
    -  준비리스트에 있는 프로세스들의 순서대로 실행상태가 됨.
  - **실행 running**
    : 프로세스가 CPU를 점유하고, 명령을 실행 중인 상태.
    - CPU(프로세서)가 사용가능해지면 해당 프로세스에 대해 CPU를 할당받음.
      프로세스는 실행상태에서 CPU를 이용해 작업한 다음 CPU를 반납함.
      작업이 끝나지 않았으면 다시 준비상태가 됨.
  - **대기 / 블록 / 봉쇄 wait / blocked / sleep**
    : 프로세스가 CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태.
    입출력 등 오래 걸리는 작업을 하는 상태에 해당한다.
    - 프로세스를 다시 사용하기 전에 입출력이 완료되기를 기다려야 한다면, 완료될 떄까지 대기상태가 된다.
    - 입출력이 완료되면 운영체제가 프로세스를 대기상태에서 준비상태로 전이시킨다.
  - **종료 terminated**
    : 프로세스가 종료 중인 일시적 상태.
    - 프로세스가 종료되었으나, 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태.
- 인터럽팅 클록 / 타이머 인터럽트
  - 운영체제는 프로세스가 CPU를 자발적으로 반납하지 않고 독점하는 경우를 방지하기 위해, 하드웨어적으로 인터럽팅 클록을 주기적으로 발생시킨다.
    프로세스가 반드시 특정 시간 간격동안만 실행되도록 한다.
  - 인터럽팅 클록이 발생하면, 실행 중인 프로세스는 CPU제어권을 강제로 운영체제에게 빼앗기고 준비상태로 상태전이 된다.
  - 운영체제는 수행 중이던 프로세스의 문맥을 저장하고, 준비상태에 있는 다음 순서의 프로세스를 실행 상태로 만든다.
- **프로세스 문맥 context**
  : 프로세스의 주소 공간(코드, 데이터, 스택 상태), 레지스터 값, 커널 상태(시스템 콜 등) 등을 포함한다.
  - 이전에 실행한 적 있던 프로세스를 다시 실행할 때, 어느 부분까지 명령을 수행했는지 그 상태를 재현해야 한다. 이 때 필요한 것이 프로세스 문맥이다.
    - 하드웨어 문맥	
      : CPU의 수행 상태를 나타냄. 프로그램 카운터값, 레지스터에 저장된 값 들을 의미함.
    - 프로세스 주소 공간
      : 각 프로세스가 가진 독자적인 주소 공간(코드, 데이터, 스택)을 의미함.
    - 커널 문맥
      : 운영체제가 프로세스를 관리하기 위해 유지하는 자료구조 (PCB, 커널스택)





---



## 스레드 Thread

### 스레드란?

- 프로세스의 실행단위.
  경량 프로세스 (LWP - Light Weight Process) 라고도 한다.
  (프로세스에서 실행 제어만 분리해서 처리하는 단위)
- 스레드는 프로세스 안에 포함된 개념이다.



- (자바) 프로그램을 실행하면 적어도 하나의 JVM이 시작된다.
  JVM이 시작된다 = 자바 프로세스가 시작한다.
  main()메소드가 수행된다 = 쓰레드가 시작된다.
- 하나의 프로세스 내에서 여러 개의 스레드가 수행된다.
  어떤 프로세스든 스레드는 하나 이상 수행된다.
- 쓰레드는 메인 매서드에서 생성, 시작된다.

#### 스레드는 왜 만들어졌는가?

- 메모리를 적게 사용하기 위해.
  - 프로세스 하나를 실행할 때는 (자바 기준) 약 32-64MB의 메모리를 점유한다.
    반면 스레드 하나를 추가할 때는 1MB이내의 메모리를 점유한다.
  - 프로세스는 운영체제로부터 Text/Data/Stack/Heap 메모리 영역을 할당받는 반면,
    스레드는 프로세스 내에서 stack영역을 제외한 나머지 메모리 영역을 같은 프로세스 내 다른 스레드와 공유한다. - 다른 스레드와 정보공유가 쉽다.
- 작업을 더 빠르게 처리하기 위해.
  - 단일 스레드로 실행할 때 보다 다중 스레드로 실행할 때 더 빨리 작업을 처리할 수 있다.





---



### 1/21 오늘의 영단어

> **synchronized** (a) 동기화된
> **synchronize** (v) 동시에 하다

> **modify** (v) 수정하다/조정하다





---

**내일 할 일**

[프로세스와 스레드의 차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

보면서 공부하고 정리하기.