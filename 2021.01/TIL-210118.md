**[210118]**

구글링, 기본서, 그룹리뷰를 통해 새로운 개념을 많이 알게 된 날이다.
공부는 열심히 해서 뿌듯하긴 한데 미션 진행이 안 되어서 찜찜하다.
TIL 올리고 미션풀이를 좀 생각해봐야겠다.



# TIL

## [함수형 프로그래밍이란?](https://www.youtube.com/watch?v=jVG5jvOzu9Y)

#### 순수함수의 개념

1. 인풋과 아웃풋이 있다.
   (중간 결과물을)인풋으로 받아 각자 맡은 작업을 하고 결과물을 아웃풋으로 내보냄.
   컨베이어 벨트처럼 함수들은 순서대로 자신에게 주어진 일들만 한다.

2. 외부 환경으로부터 철저히 독립적이다. (외부 요인의 영향을 받지 않는다)
   어떤 값을 참조하지 않고 오로지 주어진 값들로 정해진 작업만 한다.

3. (2.덕분에) 같은 인풋일 때 언제나 같은 아웃풋을 내보낸다.

   -다른 함수들에게도 아웃풋 외에 아무 영향을 끼치지 않는다.



#### 함수형 프로그래밍이 좋은 이유?

비 함수형 프로그램과 비교했을 때, 변수의 영향을 받지 않아 더 안정적이다.
외부에서 참조변수 값을 바꾸는 등의 사고(**부작용**)가 일어나지 않는다.
함수형 프로그래밍은 이런 부작용으로부터 자유로워 주목받게 됨.

> **부작용**의 의미
> : 어떤 함수의 동작에 의해, 프로그램 내 특정 상태가 변경되는 상황.

멀티쓰레드 프로그램에서, 한 변수에 여러 쓰레드가 접근할 때 부작용이 발생하기 쉽다.
이를 방지하기 위해 수동으로 쓰레드 동작을 조정할 수 있지만, 고려할 요소가 너무 많고 오류 발생 가능성이 있다.
->함수형 프로그래밍은 함수 동작에 의한  변수의 값 변경을 원천 배제함으로써 이런 오류를 방지한다. 외부 변수를 사용하더라도 그 값에 직접 접근하는 것이 아닌, 인자로 복사해가서 작업한다.



함수형 프로그램이 아무런 상태변화를 일으키지 않는다는 말이 아니다.
모든 코드를 함수형으로 짠다는 말이 아니라, 적어도 어떤 단위의 작업에 있어서 부작용 없이 안정적이고 예측가능한 프로그램을 짠다는 것이다.



#### 함수형 프로그램의 대표 특징



- 함수형 프로그래밍은 **선언형**이다.

  - '함수형' 프로그래밍 이전까지 하던 프로그래밍은 '명령형' 프로그래밍에 해당한다.
    - 명령형 프로그래밍 : A는 B와 상호작용하고 C라는 값을 참조해서 D라는 결과를 만들어내라.
    - 함수형 프로그래밍 : A-B-C-D-E작업은 F라는 결과물과 같다.

  - 순수함수들은 인풋만 똑같으면 반드시 아웃풋도 똑같다. (외부변수 영향 X)
    -> 그렇기 때문에 ABCDE작업에 정해진 인풋을 넣으면 반드시 정해진 아웃풋이 산출된다고 신뢰할 수 있다.
  - 명령형에서는 변수만 'A는 B이다'라고 생각하고, 함수는 행위 개념으로만 생각했을 것.
    하지만 함수형에서는 함수도 변수처럼 생각하며 프로그래밍해야 한다. 
    (함수를 '값'의 개념으로 생각한다)

- 함수도 '**값**'이다.
  - 함수가 '값'이라고 해서 숫자/문자열/객체 같은 명확한 결과값이 도출되는 건 아니다.
  - 순수함수라는 가정 하에, 같은 인풋일 때 아웃풋이 일정하므로 
    '예측가능한 값을 산출할 상태' 라는 값으로 이 함수를 다룰 수 있다.
- **고차함수**(HOF - Higher Order Function)
  - 함수를 '값'으로 볼 수 있다면, 함수를 다른 함수의 인자로 넣어줄 수 있다.
  - 매개변수로 다른 함수를 받는 함수 / 다른 함수를 리턴값으로 반환하는 함수를 '고차함수(고계함수)'라고 한다.
  - 고차함수를 통해 더 유연한 프로그램을 만들 수 있다.
- **커링**
  - 여러 인자를 받는 함수에 일부 인자만 넣어서, 나머지 인자를 받는 다른함수를 만들어내는 함수형 프로그래밍 기법.
- **함수 컴비네이터**
  - 함수형 언어 / 함수형 프로그래밍을 위한 라이브러리에는 컬렉션 내 요소들을 다양하게, 연속적으로 처리할 수 있는 많은 도구들이 포함되어 있다. - 자바 스트림처럼.
  - 실수할 가능성이 있지만 불가피했던 for문 등의 작업들을, 도구들을 이용해 간결하게 할 수 있다. filter, take, map 등..
    - for문 같은 반복문 요소들은 어떤 변수의 상태변화(부작용)을 필요로 한다.
      따라서 함수형 프로그래밍에서는 부작용을 일으키지 않는 재귀함수를 많이 사용한다.



## [함수형 프로그래밍이란? 정리](https://medium.com/@lazysoul/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-d881230f2a5e)

- 가변적인 상태를 불변하는 상태(Immutable)로 만들어 side effect를 없앤다.

  - f(x) = y : 함수 f에 x를 입력하면 항상 y가 나온다.
  - 함수 내에서 상태를 관리하고, 상태에 따라 결과가 달라지지 않는다.  (외부 상태는 사용하지 않는다)
  - 변수보다 상수를 사용한다.

- 함수도 객체이다 : 함수도 **1급 객체first-class citizen**이다.

  - **[1급 객체란?](https://medium.com/@lazysoul/functional-programming-%EC%97%90%EC%84%9C-1%EA%B8%89-%EA%B0%9D%EC%B2%B4%EB%9E%80-ba1aeb048059)**
    - 아래 3가지 조건을 충족하는 객체이다.
      - 변수나 데이터에 할당할 수 있다.
      - 객체의 인자로 넘길 수 있다.
      - 객체의 리턴값으로 리턴할 수 있다.
  - 자바에서는 자바8이후 함수도 1급 객체가 되었다.

- 코드를 간결하게 하고, 가독성을 높여 **로직**에 집중시킨다.

  - Lambda / Collection / Stream같은 API를 통해 직접적인 함수 호출을 함으로써 가독성을 높인다.
  - 일을 위한 일이 줄어들어, 실제 로직에만 집중할 수 있다.

- 동시성 작업을 쉽고 안전하게 구현한다.

  - immutable한 값을 사용해, 멀티쓰레드에 안전하며 보호장치(lock/unlock)가 필요없다.

  

----



### 내부 클래스 inner class

- (캡슐화 encapsulation의 한 방법) 하나의 클래스에서 어떤 공통적 작업을 수행하는 클래스가 필요한데, 다른 클래스에서는 그 클래스가 전혀 필요가 없을 때 내부 클래스를 만들어 사용한다.

### 익명 클래스 Anonymous class란?

- 내부클래스를 만드는 것보다 더 간단한 방법이 '익명 클래스'를 만드는 것이다.

- 호출하는 메소드의 매개변수로 메소드를 사용하고 싶을 떄, 생성자만 호출해 클래스를 만들어 메소드를 구현한 클래스.
  - 원래는 클래스를 만들고, 클래스 내에 메소드를 만든 다음 그 클래스의 객체를 만들어 매개변수로 사용해야 한다.(복잡)
  - 익명 클래스는 어떤 메소드를 호출하는 과정 내에 익명클래스와 메소드를 선언해 사용할 수 있다.

**익명 클래스의 장점**

- 메소드를 매개변수로 하는 메소드를 직관적으로 이해할 수 있게 함.
- 클래스를 만드는 데 드는 메모리 낭비와 성능 하락을 방지함.

**익명 클래스의 단점**

- 호출하는 메소드의 가독성이 떨어진다.

- 클래스 이름도, 객체 이름도 없기 때문에 다른 클래스/메소드에서 재사용할 수 없다.
  (내부 클래스, 익명 클래스 모두 다른 클래스에서 재사용할 일이 없을 때 만들어야 한다.)



---



## 람다 표현식 Lambda expression

- 익명클래스를 사용할 때의 낮은 가독성과 불편함을 보완하기 위해 등장함.
  - 람다표현식과 익명클래스는 서로 전환이 가능하다.
- (조건) 람다식은 기능적 인터페이스에만 적용이 가능함.

> **기능적 인터페이스 Functional Interface**
> : 하나의 메소드만 선언되어 있는 인터페이스를 의미함.



### 람다 표현식의 구성

`(int x, int y) -> x + y`

- **매개 변수 목록** `(int x, int y)`
  - 넘겨지는 매개변수들의 타입이 선언된다.
- **화살표 토큰 Arrow Token** `->`
  - 화살표 연산자라고도 한다.
- **처리식** `x + y`
  - 리턴되는 값을 표시한다.





## 클로저 closure 란?



[위키백과](https://ko.wikipedia.org/wiki/%ED%81%B4%EB%A1%9C%EC%A0%80_(%EC%BB%B4%ED%93%A8%ED%84%B0_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D))
클로저는 일급 객체 함수(first-class functions)의 개념을 이용하여 스코프에 묶인 변수를 바인딩하기 위한 일종의 기술이다. 
기능상으로, 클로저는 함수를 저장한 레코드이며, 스코프의 인수factor들은 클로저가 만들어질 때 정의된다. 스코프 내의 영역이 소멸되었어도 그에 대한 접근은 독립된 복사본인 클로저를 통해 이루어질 수 있다.

호눅스 왈..
: 클로저는 내부에서 외부 변수에 접근했을 때 만들어지는 record / 자료구조이다.
클로저는 람다계산식 Lambda Calculus의 구현체.

[생활코딩](https://opentutorials.org/course/743/6544)
내부함수가 외부함수의 맥락context에 접근할 수 있는 것을 가리킨다.
내부함수는 외부함수의 지역변수에 접근할 수 있는데, 외부함수의 실행이 끝나 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수에 접근할 수 있는 매커니즘.
외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때 까지 소멸되지 않는 특성을 가진다.



## [자바] 스트림 stream 이란?

[코딩팩토리](https://coding-factory.tistory.com/574) 및 자바기본서.

스트림은 Collection의 저장 요소를 하나씩 참조해 람다식으로 처리할 수 있는 반복자이다.

- Iterator와 비슷하지만 람다식을 쓸 수 있어 코드가 더 간결하다.
- 내부 반복자를 사용해 병렬처리가 쉽다.
- 스트림 객체는 `java.util.stream` 패키지의 Stream 인터페이스를 말한다.

- 배열에는 스트림을 사용할 수 없지만, 배열을 Collection의 List로 변환할 수는 있다.
  `Arrays.asList()`나 `Arrays.stream()`을 활용.



#### 스트림의 구조

`list.stream().filter(x -> x>10).count();`

- 스트림 생성 
  : `stream()`. 리턴 타입은 `Stream`.
  컬렉션의 목록을 스트림 객체로 변환.
  `stream()`은 순차적으로 데이터를 처리함. 

  - `stream()`, `parallelStream()`

- 중간 연산 intermediate operation 
  : `stream()`부터 종단 연산 전까지 모든 연산. 리턴 타입은 `Stream`.
  스트림 객체를 사용해 중개 연산을 처리함.
  중개연산에서는 결과값을 리턴하지 못함.
  반드시 중개 연산이 있어야 하는 것은 아님 (0개 이상의 중개연산).

  - `filter()`, `map()`, `flatMap()`, `distinct()`, `sorted()`, `peek()`, `limit()`, `skip()` 등이 있다.

- 종단 연산 terminal operation 
  : 스트림의 맨 끝 연산. 리턴 타입은 숫자값 또는 목록형 데이터.
  중개 연산에서 작업된 내용을 리턴함.

  - `forEach()`, `reduce()`, `collect()`, `toArray()`, `count()` 등이 있다.

  

