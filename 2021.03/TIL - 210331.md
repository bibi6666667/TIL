**[210331]**



- 오늘 한 일
  - 미션4피드백사항 수정 및 질문
- 배운 점
  - 스프링 의존성 주입 방법, 생성자주입의 장점
- 개선할 점
  - 햇빛 쬐고 꽃 보고 싶다..😭



---

## [미션4 피드백](https://github.com/codesquad-members-2021/spring-boot-qna/pull/133#pullrequestreview-624850229)

### To-do

- heorku 배포하기
- setId() 는 필요없다.
- 필요 없는 getter, setter 지우기

- Answer save - 생성자를 통해 주입받기

- AnswerService, QuestionService - @Autowired필드주입 말고 생성자주입으로 바꾸기
  - https://madplay.github.io/post/why-constructor-injection-is-better-than-field-injection
- deleted=false인 항목을 뷰에서 거르지 말고, 컨트롤러/DB에서 걸러서 보내기.



## [스프링] 의존성 주입 - 생성자 주입의 장점

```java
@Autowired
private AnswerRepository answerRepository;
@Autowired
private QuestionRepository questionRepository;
```

> Field Injection의 단점은 무엇이 있을까요?
> 아래 링크를 참고해서 공부해보세요~🧐

### [생성자 주입을 @Autowired를 사용하는 필드 주입보다 권장하는 이유](https://madplay.github.io/post/why-constructor-injection-is-better-than-field-injection)

스프링 프레임워크에서 의존성을 주입(DI, Dependency Injection)하는 방법은 3가지가 있다.

스프링에서는 세 방식 중 ''생성자 주입''을 가장 권장한다.

### 1.생성자 주입(Constructor Injection)

- 의존성 주입으로부터 클래스를 완벽하게 분리할 수 있다.
- 단일 생성자인 경우에는 `@Autowired` 어노테이션을 생략할 수 있다. 생성자가 두 개 이상인 경우에는 생성자에 어노테이션을 붙어야 한다.

```java
@Component
public class MadExample {

    // final로 선언할 수 있는 보너스
    private final HelloService helloService;

    // 단일 생성자인 경우는 추가적인 어노테이션이 필요 없다.
    public MadExample(HelloService helloService) {
        this.helloService = helloService;
    }
}
```

생성자로 객체를 생성하는 시점에 필요한 빈을 주입한다.

1. 생성자의 인자에 사용되는 빈을 찾거나, 빈 팩토리에서 만든다.
2. 찾은 빈으로 주입하려는 빈의 생성자를 호출한다. (빈을 먼저 생성하지 않는다)

### 2.필드 주입(Field Injection)

- 사용법이 간단하다

```java
@Component
public class MadExample {

    @Autowired
    private HelloService helloService;
}
```

(수정자 주입과 동일)

1. 빈을 먼저 생성한다
2. 어노테이션이 붙은 필드에 해당하는 빈을 찾아서 주입한다.

### 3.수정자 주입(Setter Injection)

- 반드시 setter메서드이거나 setXXX메서드가 아니어도 되며, setter와 동일한 기능을 하는 메서드에 활용한다.

```java
@Component
public class MadExample {

    private HelloService helloService;

    @Autowired
    public void setHelloService(HelloService helloService) {
        this.helloService = helloService;
    }
}
```

1. 주입받으려는 빈의 생성자를 호출하여 빈을 찾거나 빈 팩토리에 등록한다.
2. 생성자 인자에 사용하는 빈을 찾거나 만든다
3. 주입하려는 빈 객체의 수정자(setter)를 호출해 주입한다.

### 왜 생성자 주입 방식을 권장할까?

- 순환 참조를 방지할 수 있다.
  - 필드 주입 시 A가 B를, B가 A를 참조하는 등의 순환참조 상황이 발생할 수 있는데, 아무런 오류/경고 없이 애플리케이션이 구동되어 문제가 발생하기 쉽다.
  - 생성자 주입을 사용한 경우 순환참조가 발생해도 애플리케이션이 구동되지 않으며 `BeanCurrentlyInCreationException`이 발생한다. 

- 테스트에 용이하다.
  - 생성자 주입을 통해 테스트코드를 좀더 편리하게 작성할 수 있다. 
  - 단순 POJO를 이용한 테스트 코드를 만들 수 있다.
- 의존관계를 쉽게 파악할 수 있다.
  - 생성자 주입의 경우 의존성이 명시적으로 드러나기 때문이다.
- 불변성 (Immutability)
  - 필드 주입, 수정자 주입 방식은 해당 필드를 `final`로 선언할 수 없지만, 생성자 주입은 할 수 있다.
- 오류를 방지할 수 있다.
  - 불변 객체나 null이 아님이 보장될 떄는 반드시 생성자 주입을 사용한다.